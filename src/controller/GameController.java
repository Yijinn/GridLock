package controller;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Paths;

import javafx.application.Platform;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.Pane;
import javafx.scene.media.AudioClip;
import model.*;
import org.json.simple.JSONObject;
import view.*;
import view.Settings;
import view.GlobalController;


public class GameController {
    
    private GlobalController g;
    private AudioClip winSound;

    @FXML private Pane gameGrid;
    @FXML private Button settingsButton;
    @FXML private Button redoButton;
    @FXML private Label levelLabel;
    @FXML private Label moveNumberLabel;
    @FXML private Button getHintButton;
    @FXML private Button saveGameButton;
    @FXML private Button undoButton;
    @FXML private Button newGameButton;
    @FXML private Button menuButton;
    
    
    /**
     * Initialises listeners for grid changes and AudioClip for winSound
     * @param g     the GlobalController
     */
    public void init(GlobalController g) {
        this.g = g;
        winSound = new AudioClip(Paths.get("src/sounds/win.mp3").toUri().toString());
        //winSound.setVolume(value);

        /* Grab the IntVec of where you started to press */
        IntVec pressStart[] = new IntVec[1];
        gameGrid.addEventFilter(MouseEvent.MOUSE_PRESSED, e -> {
            pressStart[0] = new IntVec((int)(e.getX()/100), (int)(e.getY()/100));
        });

        /* When you release the mouse, grab the IntVec and create a newModel with the move
        generated by your mouseclicks. If the move is legal, then set the model in GlobalController
        to our new model. */
        gameGrid.addEventFilter(MouseEvent.MOUSE_RELEASED, e -> {
            IntVec pressEnd = new IntVec((int)(e.getX()/100), (int)(e.getY()/100)).clamp(0, 5);
        
            Model newModel = g.getModel().withGameStateMove(pressStart[0], pressEnd);
            if (newModel != null) {
                g.setModel(newModel);
            }
        });

        update();
    }
    
    /**
     * Disables the buttons if they cannot be used. Called every time a new board is drawn.
       Updates the move number on the sidePanel every time a new board is generated.
       Updates the level on the sidePanel every time a new Game is generated.
       Also checks if the current state is a goal state. If it is then prompt the user
       to start the next level.
     */
    public void update() {

        redoButton.setDisable(!g.getModel().getGameState().canRedo());
        undoButton.setDisable(!g.getModel().getGameState().canUndo());

        moveNumberLabel.setText("Move Number: " + g.getModel().getGameState().getMoveNumber());
        levelLabel.setText("Level: " + g.getModel().getLevel());

        if (g.getModel().getGameState().getCurrentState().hasWon()) {
            winSound.setVolume(g.getModel().getSettings().getVolume());
            winSound.play();
            if (AlertBox.display("You're a winner!", "Congratulations you won! Would you like to go to the next level?")) {
                g.setModel(g.getModel().withGameStateNext(), false);
                g.replace(new Game(g));
            }
        }
    }

    
    /**
     * Method is called when new game button is pressed. Program double check with user,
     * whether they want to start a new game.
     * @param event
     * @throws IOException
     */
    @FXML
    void startNewGame(ActionEvent event) throws IOException {
        System.out.println("Start New Model...");
        File savedFile = new File("save.json");
        if(savedFile.exists() && !savedFile.isDirectory()) {
	        if (AlertBox.display("Start a new Model", "Are you sure you want to start a new game?")) {
	            g.setModel(g.getModel().withGameStateNew());
	            g.replace(new Game(g));
	        }
        }else {
        	g.setModel(new Model().withGameStateNew());
        	g.replace(new Game(g));
        }
    }

    /**
     * Method is called when save game button is pressed
     * @param event
     * @throws IOException
     */
    @FXML
    void saveGame(ActionEvent event) throws IOException {
        save();
    }
    
    /**
     * Method is called when close request is set. Program will save game model first then exit program.
     * @throws IOException
     */
    @FXML
    public void autoSave() throws IOException {
        save();
        Platform.exit();
    }
    

    
    /**
     * Method is called every time the undo button is pressed. If an undo
     * is allowed, then it will update the Model, passing the
     * current GameState with the undo.
     * @param event
     */
    @FXML
    void undoStep(ActionEvent event) {
        System.out.println("Undo Step...");
        if (g.getModel().getGameState().canUndo()) {
            g.setModel(g.getModel().withGameStateUndo());
        } else {
            System.out.println("Cannot undo");
        }
    }

    /**
     * Method is called every time the redo button is pressed. If a redo
     * is allowed, then it will update the Model, passing the
     * current GameState with the redo.
     * @param event
     */
    @FXML
    void redoStep(ActionEvent event) {
        System.out.println("Redo Step...");
        if (g.getModel().getGameState().canRedo()) {
            g.setModel(g.getModel().withGameStateRedo());
        } else {
            System.out.println("Cannot redo");
        }
    }

    /**
     * Method is called when the settings button is pressed. Pushes the settings
     * view onto the stack.
     * @param event
     */
    @FXML
    void openSettings(ActionEvent event) {
        System.out.println("Opening Settings...");
        g.push(new Settings(g));
    }

    /**
     * Method is called when the menu button is pressed. Saves the game before
     * pushing the main menu view onto the stack.
     * @throws IOException
     */
    @FXML
    void menu() throws IOException {
    	save();
    	g.push(new MainMenu(g));
    }
    
    
    /**
     * Save method will save the game model, and will be called when close or save game request is triggered
     * @throws IOException
     */
    private void save() throws IOException {
        JSONObject o = g.getModel().toJson();
        BufferedWriter writer = new BufferedWriter(new FileWriter("save.json"));
        writer.write(o.toString());
        writer.close();
        System.out.println("Model saved!");
    }
    
    /**
     * Updates the model to supply a hint
     */
    public void getHint(ActionEvent e) {
        System.out.println("Getting a hint");
        Model newModel = g.getModel().withGameStateHint();
        if (newModel != null) g.setModel(newModel);
    }
    
    
    
    @FXML
    void initialize() {
        assert settingsButton != null : "fx:id=\"settingsButton\" was not injected: check your FXML file 'game.fxml'.";
        assert redoButton != null : "fx:id=\"redoButton\" was not injected: check your FXML file 'game.fxml'.";
        assert getHintButton != null : "fx:id=\"getHintButton\" was not injected: check your FXML file 'game.fxml'.";
        assert saveGameButton != null : "fx:id=\"saveGameButton\" was not injected: check your FXML file 'game.fxml'.";
        assert undoButton != null : "fx:id=\"undoButton\" was not injected: check your FXML file 'game.fxml'.";
        assert newGameButton != null : "fx:id=\"newGameButton\" was not injected: check your FXML file 'game.fxml'.";
        assert menuButton != null : "fx:id=\"menuButton\" was not injceted: check your FXML file 'game.fxml.'";
    }
}
